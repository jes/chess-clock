#!/usr/bin/perl

use strict;
use warnings;

use Chess::Rep;
use Storable qw(dclone);
use List::Util qw(shuffle);

my $game = Chess::Rep->new();

my $longest_game = 0;
my $observed_fen = {};
$observed_fen->{$game->get_fen} = 1;

dfs($game, "", 1);

sub dfs {
    my ($orig_game, $moves_str, $nmoves) = @_;

    # on white's move, append move number
    my $is_white = 0;
    if ($orig_game->to_move) {
        $is_white = 1;
        $moves_str .= "$nmoves. ";
        $nmoves++;
    }

    if ($nmoves > $longest_game) {
        print "$moves_str\n";
        $longest_game = $nmoves;
    }

    my @moves = shuffle legal_moves($orig_game);

    while (my $move = shift @moves) {
        my $game = dclone($orig_game);

        $game->go_move($move);
        my $fen = $game->get_fen;
        next if $observed_fen->{$fen}; # never repeat

        my $san = move_to_san($orig_game, $move);
        my $is_capture = ($san =~ /x/ ? 1 : 0);
        my $is_pawn_move = 0; # TODO
        my $want_capture = ($nmoves%74 == 0) && ((($nmoves/74)%2) == $is_white);
        next if ($is_capture || $is_pawn_move) != $want_capture; # we only want to capture to avoid the 75-move draw

        $observed_fen->{$fen} = 1;
        dfs($game, $moves_str . move_to_san($orig_game, $move) . " ", $nmoves);
        delete $observed_fen->{$fen};
    }
}

sub legal_moves {
    my ($game) = @_;

    my $player = $game->to_move ? 'w' : 'b';
    my @moves = @{ $game->status->{moves} };
    my @san_moves;

    my @legal_moves;

    for my $m (@moves) {
        # XXX: why are these returned in uppercase when Chess::Rep doesn't accept uppercase??
        my $from = lc Chess::Rep::get_field_id($m->{from});
        my $to = lc Chess::Rep::get_field_id($m->{to});

        my $newgame = dclone($game);
        $newgame->go_move("$from-$to");

        # don't accept moves that end the game
        next if $newgame->status->{mate} || $newgame->status->{stalemate};

        push @legal_moves, "$from-$to";
    }

    return sort { $a cmp $b } @legal_moves;
}

sub move_to_san {
    my ($game, $move) = @_;

    my $newgame = dclone($game);
    my $san = $newgame->go_move($move)->{san};

    my ($from, $to) = split /-/, $move;

    # if this is a pawn moving to the final rank, promote it
    if ($to =~ /[81]/ && ($newgame->get_piece_at($to) & 0x1)) {
        my $append = '';
        $append = '#' if $san =~ /#/;
        $append = '+' if $san =~ /\+/;
        $san =~ s/[#+]//;

        # promote a pawn to a queen
        return "$san=Q$append";
    } else {
        return $san;
    }
}
